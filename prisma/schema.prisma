generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model DealCategoryMaster {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(100)
  description String?
  icon        String?  @db.VarChar(100)
  color       String?  @db.VarChar(7)
  sortOrder   Int      @default(0)
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deals       Deal[]

  @@index([active, sortOrder])
}

model DealTypeMaster {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(50)
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deals       Deal[]

  @@index([active])
}

model PointEventTypeMaster {
  id          Int              @id @default(autoincrement())
  name        String           @unique @db.VarChar(50)
  description String?
  points      Int
  active      Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  pointEvents UserPointEvent[]

  @@index([active])
}

model User {
  id                  Int                       @id @default(autoincrement())
  email               String                    @unique
  name                String?
  password            String?
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt
  emailVerifiedAt     DateTime?
  lastLoginAt         DateTime?
  role                UserRole                  @default(USER)
  points              Int                       @default(0)
  monthlyPoints       Int                       @default(0)
  referralCode        String?                   @unique
  referredByUserId    Int?
  birthday            DateTime?
  avatarUrl           String?
  coins               Int                       @default(0)
  experiencePoints    Int                       @default(0)
  loyaltyTier         LoyaltyTier               @default(BRONZE)
  totalSpent          Float                     @default(0)
  bookings            Booking[]
  checkIns            CheckIn[]
  CoinTransaction     CoinTransaction[]
  kickbackEvents      KickbackEvent[]
  merchant            Merchant?
  PaymentTransaction  PaymentTransaction[]
  referredBy          User?                     @relation("UserReferrals", fields: [referredByUserId], references: [id])
  referrals           User[]                    @relation("UserReferrals")
  UserAchievement     UserAchievement[]
  savedDeals          UserDeal[]
  pointEvents         UserPointEvent[]
  streak              UserStreak?
  // Loyalty Points Relations
  loyaltyBalances     UserMerchantLoyalty[]
  loyaltyTransactions LoyaltyPointTransaction[]
  loyaltyRedemptions  LoyaltyRedemption[]
  orders              Order[]
  // Heist Token Relations
  heistToken          HeistToken?
  heistsAsAttacker    Heist[]               @relation("HeistsAsAttacker")
  heistsAsVictim      Heist[]               @relation("HeistsAsVictim")
  heistNotifications  HeistNotification[]
  // Heist Item Relations
  heistItems          UserHeistItem[]
  heistItemUsages     HeistItemUsage[]
  socialAccounts      SocialAccount[]
  organizedEvents     Event[]               @relation("EventOrganizer")
  eventTickets        EventTicket[]         @relation("EventTickets")
  originalEventTickets EventTicket[]        @relation("OriginalTicketOwner")
  eventAttendees      EventAttendee[]       @relation("EventAttendees")
  eventCheckIns       EventCheckIn[]        @relation("EventCheckIns")
  eventAddOnPurchases EventAddOnPurchase[]
  // Nudge Relations
  userNudges          UserNudge[]
  nudgePreferences    UserNudgePreferences?
  // Bounty & Kitty Game Relations
  bountyProgress      BountyProgress[]
  kittyGuesses        KittyGuess[]
  kittyGamesWon       KittyGame[]       @relation("KittyGameWinner")
  kittyGamesCreated   KittyGame[]       @relation("KittyGameCreator")

  @@index([referredByUserId])
  @@index([loyaltyTier])
  @@index([totalSpent])
}

model SocialAccount {
  id              Int             @id @default(autoincrement())
  provider        SocialProvider
  providerUserId  String
  accessToken     String?
  refreshToken    String?
  expiresAt       DateTime?
  profile         Json?
  userId          Int
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@index([userId, provider])
}

model Merchant {
  id                  Int                       @id @default(autoincrement())
  businessName        String
  address             String
  description         String?
  logoUrl             String?
  status              MerchantStatus            @default(PENDING)
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt
  ownerId             Int                       @unique
  latitude            Float?
  longitude           Float?
  city                String?
  phoneNumber         String?
  businessType        BusinessType              @default(LOCAL)
  bookings            Booking[]
  bookingSettings     BookingSettings?
  deals               Deal[]
  kickbackEvents      KickbackEvent[]
  menuCollections     MenuCollection[]
  menuItems           MenuItem[]
  owner               User                      @relation(fields: [ownerId], references: [id])
  stores              Store[]
  tables              Table[]
  timeSlots           TimeSlot[]
  // Loyalty Points Relations
  loyaltyProgram      MerchantLoyaltyProgram?
  userLoyaltyBalances UserMerchantLoyalty[]
  loyaltyTransactions LoyaltyPointTransaction[]
  loyaltyRedemptions  LoyaltyRedemption[]
  orders              Order[]
  events              Event[]
  kittyGames          KittyGame[]
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model Deal {
  id                     Int                @id @default(autoincrement())
  title                  String
  description            String
  discountPercentage     Int?
  discountAmount         Float?
  startTime              DateTime
  endTime                DateTime
  redemptionInstructions String
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  merchantId             Int
  recurringDays          String?
  imageUrls              String[]
  kickbackEnabled        Boolean            @default(false)
  offerTerms             String?
  categoryId             Int
  dealTypeId             Int
  
  // Bounty Deal fields
  bountyRewardAmount     Float?             // Cash back amount per referral
  minReferralsRequired   Int?               // Minimum friends to bring
  bountyQRCode           String?            // QR code data for bounty verification
  
  // Hidden Deal fields
  accessCode             String?            // Secret code to access hidden deals
  
  // Redeem Now (Flash Sale) fields
  isFlashSale            Boolean            @default(false) // Urgency flag
  maxRedemptions         Int?               // Maximum number of redemptions allowed
  currentRedemptions     Int                @default(0)     // Current redemption count
  
  checkIns               CheckIn[]
  category               DealCategoryMaster @relation(fields: [categoryId], references: [id])
  dealType               DealTypeMaster     @relation(fields: [dealTypeId], references: [id])
  merchant               Merchant           @relation(fields: [merchantId], references: [id])
  menuItems              DealMenuItem[]
  kickbackEvents         KickbackEvent[]
  savedByUsers           UserDeal[]
  pointEvents            UserPointEvent[]
  bountyProgress         BountyProgress[]

  @@index([accessCode])
  @@index([merchantId, dealTypeId])
  @@index([isFlashSale, endTime])
}

model UserDeal {
  id      Int      @id @default(autoincrement())
  userId  Int
  dealId  Int
  savedAt DateTime @default(now())
  deal    Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, dealId])
}

model UserPointEvent {
  id               Int                  @id @default(autoincrement())
  userId           Int
  dealId           Int?
  points           Int
  createdAt        DateTime             @default(now())
  pointEventTypeId Int
  deal             Deal?                @relation(fields: [dealId], references: [id])
  pointEventType   PointEventTypeMaster @relation(fields: [pointEventTypeId], references: [id])
  user             User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, pointEventTypeId])
  @@index([userId, dealId])
  @@index([createdAt])
  @@index([createdAt, userId])
  @@index([pointEventTypeId, createdAt]) // For event type filtering in period queries
}

model CheckIn {
  id             Int      @id @default(autoincrement())
  userId         Int
  dealId         Int
  merchantId     Int
  latitude       Float
  longitude      Float
  distanceMeters Float
  createdAt      DateTime @default(now())
  deal           Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, dealId])
  @@index([merchantId])
  @@index([userId, createdAt])
}

model UserStreak {
  id                     Int       @id @default(autoincrement())
  userId                 Int       @unique
  currentStreak          Int       @default(0)
  longestStreak          Int       @default(0)
  lastCheckInDate        DateTime?
  currentWeekCheckIns    Int       @default(0)
  totalCheckIns          Int       @default(0)
  streakStartDate        DateTime?
  currentDiscountPercent Float     @default(0)
  maxDiscountReached     Boolean   @default(false)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([currentStreak])
}

model City {
  id        Int      @id @default(autoincrement())
  name      String
  state     String
  active    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  stores    Store[]
  events    Event[]

  @@unique([name, state])
  @@index([active, name])
}

model Store {
  id         Int      @id @default(autoincrement())
  merchantId Int
  cityId     Int
  address    String
  latitude   Float?
  longitude  Float?
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  city       City     @relation(fields: [cityId], references: [id])
  merchant   Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
  @@index([cityId])
  @@index([active, cityId])
}

model MenuItem {
  id                 Int                  @id @default(autoincrement())
  merchantId         Int
  name               String
  description        String?
  price              Float
  category           String
  imageUrl           String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  happyHourPrice     Float?
  isHappyHour        Boolean              @default(false)
  dealType           MenuDealType         @default(STANDARD)
  isSurprise         Boolean              @default(false)
  surpriseRevealTime String?
  validDays          String?
  validEndTime       String?
  validStartTime     String?
  dealLinks          DealMenuItem[]
  collectionItems    MenuCollectionItem[]
  merchant           Merchant             @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
  @@index([merchantId, dealType])
  @@index([merchantId, isHappyHour])
  @@index([dealType])
}

model DealMenuItem {
  dealId            Int
  menuItemId        Int
  isHidden          Boolean  @default(false)
  assignedAt        DateTime @default(now())
  customDiscount    Float?
  customPrice       Float?
  discountAmount    Float?
  useGlobalDiscount Boolean  @default(true)
  deal              Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)
  menuItem          MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)

  @@id([dealId, menuItemId])
  @@index([menuItemId])
  @@index([dealId])
}

model MenuCollection {
  id          Int                  @id @default(autoincrement())
  merchantId  Int
  name        String
  description String?
  isActive    Boolean              @default(true)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  merchant    Merchant             @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  items       MenuCollectionItem[]

  @@index([merchantId])
  @@index([merchantId, isActive])
  @@index([name])
}

model MenuCollectionItem {
  collectionId   Int
  menuItemId     Int
  sortOrder      Int            @default(0)
  isActive       Boolean        @default(true)
  customPrice    Float?
  customDiscount Float?
  notes          String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  collection     MenuCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  menuItem       MenuItem       @relation(fields: [menuItemId], references: [id], onDelete: Cascade)

  @@id([collectionId, menuItemId])
  @@index([collectionId])
  @@index([menuItemId])
  @@index([collectionId, sortOrder])
}

model KickbackEvent {
  id                Int      @id @default(autoincrement())
  merchantId        Int
  dealId            Int
  userId            Int
  amountEarned      Float
  sourceAmountSpent Float
  inviteeCount      Int      @default(1)
  createdAt         DateTime @default(now())
  deal              Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)
  merchant          Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([merchantId, createdAt])
  @@index([userId])
  @@index([dealId])
  @@index([userId, createdAt])
}

model Table {
  id         Int         @id @default(autoincrement())
  merchantId Int
  name       String
  capacity   Int
  features   String[]
  status     TableStatus @default(AVAILABLE)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  bookings   Booking[]
  merchant   Merchant    @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
  @@index([merchantId, status])
  @@index([status])
}

model TimeSlot {
  id          Int       @id @default(autoincrement())
  merchantId  Int
  dayOfWeek   Int
  startTime   String
  endTime     String
  duration    Int
  maxBookings Int
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  bookings    Booking[]
  merchant    Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId, dayOfWeek])
  @@index([merchantId, dayOfWeek, startTime])
  @@index([isActive])
}

model Booking {
  id               Int           @id @default(autoincrement())
  merchantId       Int
  tableId          Int
  timeSlotId       Int
  userId           Int
  bookingDate      DateTime
  partySize        Int
  status           BookingStatus @default(PENDING)
  specialRequests  String?
  contactPhone     String?
  contactEmail     String?
  confirmationCode String        @unique
  notes            String?
  confirmedAt      DateTime?
  cancelledAt      DateTime?
  cancelledBy      Int?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  merchant         Merchant      @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  table            Table         @relation(fields: [tableId], references: [id], onDelete: Cascade)
  timeSlot         TimeSlot      @relation(fields: [timeSlotId], references: [id], onDelete: Cascade)
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([merchantId, bookingDate])
  @@index([merchantId, status])
  @@index([userId])
  @@index([tableId, bookingDate])
  @@index([timeSlotId, bookingDate])
  @@index([bookingDate, status])
  @@index([confirmationCode])
  @@index([tableId, bookingDate, status]) // For availability queries
}

model BookingSettings {
  id                   Int      @id @default(autoincrement())
  merchantId           Int      @unique
  advanceBookingDays   Int      @default(30)
  minPartySize         Int      @default(1)
  maxPartySize         Int      @default(12)
  bookingDuration      Int      @default(120)
  requiresConfirmation Boolean  @default(true)
  allowsModifications  Boolean  @default(true)
  allowsCancellations  Boolean  @default(true)
  cancellationHours    Int      @default(24)
  autoConfirm          Boolean  @default(false)
  sendReminders        Boolean  @default(true)
  reminderHours        Int      @default(2)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  merchant             Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
}

model Achievement {
  id              Int               @id @default(autoincrement())
  name            String            @unique
  description     String
  type            AchievementType
  icon            String?
  coinReward      Int               @default(0)
  xpReward        Int               @default(0)
  criteria        Json
  isActive        Boolean           @default(true)
  sortOrder       Int               @default(0)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  UserAchievement UserAchievement[]

  @@index([isActive, sortOrder])
  @@index([type, isActive])
}

model CoinTransaction {
  id                 Int                 @id @default(autoincrement())
  userId             Int
  type               CoinTransactionType
  amount             Int
  balanceBefore      Int
  balanceAfter       Int
  description        String
  metadata           Json?
  relatedPaymentId   Int?
  createdAt          DateTime            @default(now())
  PaymentTransaction PaymentTransaction? @relation(fields: [relatedPaymentId], references: [id])
  User               User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([type])
  @@index([userId, createdAt])
}

model LoyaltyTierConfig {
  id                 Int         @id @default(autoincrement())
  tier               LoyaltyTier @unique
  minSpent           Float
  coinMultiplier     Float       @default(1.0)
  discountPercentage Float       @default(0)
  specialPerks       Json?
  tierColor          String?
  tierIcon           String?
  isActive           Boolean     @default(true)
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  @@index([isActive])
  @@index([minSpent])
}

model PaymentTransaction {
  id              Int               @id @default(autoincrement())
  userId          Int
  paypalOrderId   String?           @unique
  paypalPaymentId String?
  amount          Float
  coinsPurchased  Int
  status          PaymentStatus     @default(PENDING)
  paypalResponse  Json?
  failureReason   String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  // New generic payment fields
  purpose         PaymentPurpose    @default(COIN_PURCHASE)
  gateway         PaymentGateway    @default(PAYPAL)
  currency        String            @default("USD")
  relatedOrderId  Int?
  order           Order?            @relation(fields: [relatedOrderId], references: [id])
  CoinTransaction CoinTransaction[]
  User            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventTickets    EventTicket[]
  eventAddOnPurchases EventAddOnPurchase[]

  @@index([paypalOrderId])
  @@index([paypalPaymentId])
  @@index([status])
  @@index([userId, createdAt])
  @@index([relatedOrderId])
}

model UserAchievement {
  id            Int         @id @default(autoincrement())
  userId        Int
  achievementId Int
  progress      Json
  isCompleted   Boolean     @default(false)
  completedAt   DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  Achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  User          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([achievementId])
  @@index([userId, isCompleted])
}

// ===== LOYALTY POINTS SYSTEM =====

model MerchantLoyaltyProgram {
  id                    Int                       @id @default(autoincrement())
  merchantId            Int                       @unique
  isActive              Boolean                   @default(true)
  pointsPerDollar       Float                     @default(0.4) // 2 points per $5 = 0.4 points per dollar
  minimumPurchase       Float                     @default(0.01) // Minimum purchase to earn points
  minimumRedemption     Int                       @default(25) // Minimum points to redeem
  redemptionValue       Float                     @default(5.0) // Dollar value for minimum redemption (25 pts = $5)
  pointExpirationDays   Int? // Points expire after X days (null = never expire)
  allowCombineWithDeals Boolean                   @default(true) // Can loyalty be combined with deals?
  earnOnDiscounted      Boolean                   @default(false) // Earn points on discounted amount or original?
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  merchant              Merchant                  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  userBalances          UserMerchantLoyalty[]
  transactions          LoyaltyPointTransaction[]
  redemptions           LoyaltyRedemption[]
  orders                Order[]

  @@index([merchantId, isActive])
  @@index([isActive])
}

model UserMerchantLoyalty {
  id               Int                       @id @default(autoincrement())
  userId           Int
  merchantId       Int
  loyaltyProgramId Int
  currentBalance   Int                       @default(0) // Current available points
  lifetimeEarned   Int                       @default(0) // Total points ever earned
  lifetimeRedeemed Int                       @default(0) // Total points ever redeemed
  lastEarnedAt     DateTime?
  lastRedeemedAt   DateTime?
  tier             String? // Optional tier (Bronze, Silver, Gold, etc.)
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  user             User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  merchant         Merchant                  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  loyaltyProgram   MerchantLoyaltyProgram    @relation(fields: [loyaltyProgramId], references: [id], onDelete: Cascade)
  transactions     LoyaltyPointTransaction[]
  redemptions      LoyaltyRedemption[]

  @@unique([userId, merchantId])
  @@index([userId])
  @@index([merchantId])
  @@index([currentBalance])
  @@index([userId, merchantId, currentBalance])
}

model LoyaltyPointTransaction {
  id                  Int                    @id @default(autoincrement())
  userId              Int
  merchantId          Int
  loyaltyProgramId    Int
  userLoyaltyId       Int
  type                LoyaltyTransactionType
  points              Int
  balanceBefore       Int
  balanceAfter        Int
  description         String
  metadata            Json? // Store order details, etc.
  relatedOrderId      Int?
  relatedRedemptionId Int?
  createdAt           DateTime               @default(now())
  user                User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  merchant            Merchant               @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  loyaltyProgram      MerchantLoyaltyProgram @relation(fields: [loyaltyProgramId], references: [id], onDelete: Cascade)
  userLoyalty         UserMerchantLoyalty    @relation(fields: [userLoyaltyId], references: [id], onDelete: Cascade)
  order               Order?                 @relation(fields: [relatedOrderId], references: [id])
  redemption          LoyaltyRedemption?     @relation(fields: [relatedRedemptionId], references: [id])

  @@index([userId, createdAt])
  @@index([merchantId, createdAt])
  @@index([type])
  @@index([createdAt])
  @@index([userId, merchantId, createdAt])
}

model LoyaltyRedemption {
  id                 Int                       @id @default(autoincrement())
  userId             Int
  merchantId         Int
  loyaltyProgramId   Int
  userLoyaltyId      Int
  pointsUsed         Int
  discountValue      Float
  orderId            Int?
  status             LoyaltyRedemptionStatus   @default(PENDING)
  redeemedAt         DateTime                  @default(now())
  appliedAt          DateTime?
  cancelledAt        DateTime?
  cancellationReason String?
  metadata           Json?
  createdAt          DateTime                  @default(now())
  updatedAt          DateTime                  @updatedAt
  user               User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  merchant           Merchant                  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  loyaltyProgram     MerchantLoyaltyProgram    @relation(fields: [loyaltyProgramId], references: [id], onDelete: Cascade)
  userLoyalty        UserMerchantLoyalty       @relation(fields: [userLoyaltyId], references: [id], onDelete: Cascade)
  order              Order?                    @relation(fields: [orderId], references: [id])
  transactions       LoyaltyPointTransaction[]

  @@index([userId, status])
  @@index([merchantId, status])
  @@index([status])
  @@index([redeemedAt])
  @@index([userId, merchantId, redeemedAt])
}

model Order {
  id                    Int                       @id @default(autoincrement())
  userId                Int
  merchantId            Int
  loyaltyProgramId      Int?
  orderNumber           String                    @unique
  subtotal              Float // Original amount before discounts
  discountAmount        Float                     @default(0) // Total discounts applied
  loyaltyDiscount       Float                     @default(0) // Discount from loyalty redemption
  finalAmount           Float // Amount after all discounts
  loyaltyPointsEarned   Int                       @default(0) // Points earned from this order
  loyaltyPointsRedeemed Int                       @default(0) // Points used for this order
  status                OrderStatus               @default(PENDING)
  orderItems            Json // Store items as JSON array
  paymentMethod         String?
  paymentTransactionId  String?
  notes                 String?
  metadata              Json?
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  completedAt           DateTime?
  cancelledAt           DateTime?
  user                  User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  merchant              Merchant                  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  loyaltyProgram        MerchantLoyaltyProgram?   @relation(fields: [loyaltyProgramId], references: [id])
  loyaltyRedemptions    LoyaltyRedemption[]
  loyaltyTransactions   LoyaltyPointTransaction[]
  payments              PaymentTransaction[]

  @@index([userId])
  @@index([merchantId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, merchantId, createdAt])
  @@index([orderNumber])
}

// ===== HEIST TOKEN SYSTEM =====

model HeistToken {
  id              Int      @id @default(autoincrement())
  userId          Int      @unique
  balance         Int      @default(0)
  totalEarned     Int      @default(0)
  totalSpent      Int      @default(0)
  lastEarnedAt    DateTime?
  lastSpentAt     DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  heistsAsAttacker Heist[] @relation("HeistTokenAttacker")

  @@index([userId])
  @@index([balance])
  @@index([lastSpentAt])
}

model Heist {
  id                  Int         @id @default(autoincrement())
  attackerId          Int
  victimId            Int
  pointsStolen        Int
  victimPointsBefore  Int
  victimPointsAfter   Int
  attackerPointsBefore Int
  attackerPointsAfter  Int
  tokenSpent          Boolean     @default(true)
  status              HeistStatus @default(SUCCESS)
  failureReason       String?
  ipAddress           String?
  createdAt           DateTime    @default(now())
  attacker            User        @relation("HeistsAsAttacker", fields: [attackerId], references: [id], onDelete: Cascade, map: "Heist_attacker_fkey")
  victim              User        @relation("HeistsAsVictim", fields: [victimId], references: [id], onDelete: Cascade)
  attackerToken       HeistToken  @relation("HeistTokenAttacker", fields: [attackerId], references: [userId], map: "Heist_attackerToken_fkey")
  notifications       HeistNotification[]
  itemUsages          HeistItemUsage[]

  @@index([attackerId, createdAt])
  @@index([victimId, createdAt])
  @@index([createdAt])
  @@index([status])
  @@index([attackerId, status])
  @@index([victimId, status])
  @@index([attackerId, victimId]) // For cooldown checks between specific users
}

model HeistNotification {
  id          Int                    @id @default(autoincrement())
  userId      Int
  heistId     Int?
  type        HeistNotificationType
  message     String
  metadata    Json?
  read        Boolean                @default(false)
  emailSent   Boolean                @default(false)
  emailSentAt DateTime?
  createdAt   DateTime               @default(now())
  user        User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  heist       Heist?                 @relation(fields: [heistId], references: [id], onDelete: SetNull)

  @@index([userId, read])
  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([type])
}

// ===== EVENT MANAGEMENT SYSTEM (MVP) =====

model Event {
  id                  Int                 @id @default(autoincrement())
  title               String
  description         String              @db.Text
  shortDescription    String?             @db.VarChar(500)
  eventType           EventType
  status              EventStatus         @default(DRAFT)
  organizerId         Int
  merchantId          Int?
  venueName           String?
  venueAddress        String?
  latitude            Float?
  longitude           Float?
  cityId              Int?
  isVirtualEvent      Boolean             @default(false)
  virtualEventUrl     String?
  startDate           DateTime
  endDate             DateTime
  timezone            String              @default("America/New_York")
  isMultiDay          Boolean             @default(false)
  maxAttendees        Int?
  currentAttendees    Int                 @default(0)
  enableWaitlist      Boolean             @default(false)
  waitlistCapacity    Int?
  isFreeEvent         Boolean             @default(false)
  enablePresale       Boolean             @default(false)
  presaleStartDate    DateTime?
  presaleEndDate      DateTime?
  coverImageUrl       String?
  imageGallery        String[]
  videoUrl            String?
  isPrivate           Boolean             @default(false)
  accessCode          String?             @unique
  requiresApproval    Boolean             @default(false)
  minAge              Int?
  ageVerificationReq  Boolean             @default(false)
  tags                String[]
  categoryId          Int?
  socialProofCount    Int                 @default(0)
  trendingScore       Float               @default(0)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  publishedAt         DateTime?
  cancelledAt         DateTime?

  organizer           User                @relation("EventOrganizer", fields: [organizerId], references: [id])
  merchant            Merchant?           @relation(fields: [merchantId], references: [id])
  city                City?               @relation(fields: [cityId], references: [id])
  ticketTiers         EventTicketTier[]
  tickets             EventTicket[]
  attendees           EventAttendee[]
  addOns              EventAddOn[]
  checkIns            EventCheckIn[]

  @@index([organizerId, status])
  @@index([eventType, status])
  @@index([startDate, status])
  @@index([cityId, startDate])
  @@index([status, publishedAt])
  @@index([trendingScore])
  @@index([accessCode])
}

model EventTicketTier {
  id                  Int                 @id @default(autoincrement())
  eventId             Int
  name                String
  description         String?
  tier                TicketTier
  price               Float
  serviceFee          Float               @default(0)
  taxRate             Float               @default(0)
  totalQuantity       Int
  soldQuantity        Int                 @default(0)
  reservedQuantity    Int                 @default(0)
  minPerOrder         Int                 @default(1)
  maxPerOrder         Int                 @default(10)
  maxPerUser          Int?
  isPresaleOnly       Boolean             @default(false)
  presaleCode         String?
  validDates          DateTime[]
  isActive            Boolean             @default(true)
  salesStartDate      DateTime?
  salesEndDate        DateTime?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  event               Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets             EventTicket[]

  @@index([eventId, isActive])
  @@index([eventId, tier])
}

model EventTicket {
  id                   Int                 @id @default(autoincrement())
  ticketTierId         Int
  eventId              Int
  userId               Int
  ticketNumber         String              @unique
  qrCode               String              @unique
  status               TicketStatus        @default(RESERVED)
  purchasePrice        Float
  paymentTransactionId Int?
  purchasedAt          DateTime?
  checkedInAt          DateTime?
  checkedInBy          Int?
  originalOwnerId      Int
  transferredAt        DateTime?
  transferredTo        Int?
  refundedAt           DateTime?
  refundAmount         Float?
  refundReason         String?
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt

  ticketTier           EventTicketTier     @relation(fields: [ticketTierId], references: [id])
  event                Event               @relation(fields: [eventId], references: [id])
  user                 User                @relation("EventTickets", fields: [userId], references: [id])
  originalOwner        User                @relation("OriginalTicketOwner", fields: [originalOwnerId], references: [id])
  paymentTransaction   PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])
  checkIns             EventCheckIn[]
  addOnPurchases       EventAddOnPurchase[]

  @@index([userId, status])
  @@index([eventId, status])
  @@index([ticketNumber])
  @@index([qrCode])
  @@index([paymentTransactionId])
}

model EventAttendee {
  id                  Int                 @id @default(autoincrement())
  eventId             Int
  userId              Int
  attendeeType        AttendeeType        @default(TICKET_HOLDER)
  rsvpStatus          String?
  rsvpedAt            DateTime?
  waitlistPosition    Int?
  waitlistJoinedAt    DateTime?
  waitlistApprovedAt  DateTime?
  guestCount          Int                 @default(1)
  guestNames          Json?
  dietaryRestrictions String?
  accessibilityNeeds  String?
  specialRequests     String?
  smsNotifications    Boolean             @default(false)
  phoneNumber         String?
  emailNotifications  Boolean             @default(true)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  event               Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user                User                @relation("EventAttendees", fields: [userId], references: [id])

  @@unique([eventId, userId])
  @@index([eventId, attendeeType])
  @@index([userId])
  @@index([waitlistPosition])
}

model EventCheckIn {
  id                  Int                 @id @default(autoincrement())
  eventId             Int
  userId              Int
  ticketId            Int?
  checkedInAt         DateTime            @default(now())
  checkedInBy         Int?
  checkInMethod       String              @default("QR_SCAN")
  locationName        String?
  latitude            Float?
  longitude           Float?

  event               Event               @relation(fields: [eventId], references: [id])
  user                User                @relation("EventCheckIns", fields: [userId], references: [id])
  ticket              EventTicket?        @relation(fields: [ticketId], references: [id])

  @@index([eventId, checkedInAt])
  @@index([userId])
  @@index([ticketId])
}

model EventAddOn {
  id                  Int                 @id @default(autoincrement())
  eventId             Int
  name                String
  description         String?
  category            String
  price               Float
  isOptional          Boolean             @default(true)
  totalQuantity       Int?
  soldQuantity        Int                 @default(0)
  maxPerUser          Int                 @default(1)
  availableFrom       DateTime?
  availableUntil      DateTime?
  isActive            Boolean             @default(true)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  event               Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  purchases           EventAddOnPurchase[]

  @@index([eventId, isActive])
  @@index([category])
}

model EventAddOnPurchase {
  id                   Int                 @id @default(autoincrement())
  addOnId              Int
  userId               Int
  ticketId             Int?
  paymentTransactionId Int?
  quantity             Int                 @default(1)
  unitPrice            Float
  totalPrice           Float
  purchasedAt          DateTime            @default(now())

  addOn                EventAddOn          @relation(fields: [addOnId], references: [id])
  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  ticket               EventTicket?        @relation(fields: [ticketId], references: [id])
  paymentTransaction   PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])

  @@index([addOnId])
  @@index([userId])
  @@index([paymentTransactionId])
}

enum UserRole {
  USER
  MERCHANT
  ADMIN
  EVENT_ORGANIZER
  VENDOR
  EVENT_OWNER
  SUPER_ADMIN
}

enum MerchantStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

enum BusinessType {
  NATIONAL
  LOCAL
}

enum DealCategory {
  FOOD_AND_BEVERAGE
  RETAIL
  ENTERTAINMENT
  HEALTH_AND_FITNESS
  BEAUTY_AND_SPA
  AUTOMOTIVE
  TRAVEL
  EDUCATION
  TECHNOLOGY
  HOME_AND_GARDEN
  OTHER
}

enum DealType {
  STANDARD
  HAPPY_HOUR
  RECURRING
}

enum MenuDealType {
  HAPPY_HOUR_BOUNTY
  HAPPY_HOUR_SURPRISE
  HAPPY_HOUR_LATE_NIGHT
  HAPPY_HOUR_MID_DAY
  HAPPY_HOUR_MORNINGS
  REDEEM_NOW_BOUNTY
  REDEEM_NOW_SURPRISE
  STANDARD
  RECURRING
}

enum PointEventType {
  SIGNUP
  FIRST_CHECKIN_DEAL
  CHECKIN
  COIN_PURCHASE
  ACHIEVEMENT_UNLOCK
  LOYALTY_BONUS
  REFERRAL_BONUS
  HEIST_GAIN
  HEIST_LOSS
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  OUT_OF_ORDER
}

enum AchievementType {
  FIRST_PURCHASE
  SPENDING_MILESTONE
  CHECK_IN_STREAK
  REFERRAL_COUNT
  DEAL_SAVER
  LOYALTY_TIER
  SPECIAL_EVENT
}

enum CoinTransactionType {
  PURCHASE
  EARNED
  SPENT
  BONUS
  REFUND
}

enum LoyaltyTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  DIAMOND
}

enum SocialProvider {
  GOOGLE
  FACEBOOK
  INSTAGRAM
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum PaymentGateway {
  PAYPAL
  STRIPE
}

enum PaymentPurpose {
  COIN_PURCHASE
  DEAL_PURCHASE
  BOOKING_PREPAY
  MENU_ORDER
  EVENT_TICKET
  EVENT_ADDON
  EVENT_VENDOR_FEE
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
  SOLD_OUT
}

enum EventType {
  PARTY
  BAR_CRAWL
  SPORTS_TOURNAMENT
  FESTIVAL
  RSVP_EVENT
  WAGBT
}

enum TicketTier {
  GENERAL_ADMISSION
  VIP
  PREMIUM
  EARLY_BIRD
  ALL_ACCESS
  DAY_PASS
}

enum TicketStatus {
  RESERVED
  CONFIRMED
  CHECKED_IN
  CANCELLED
  TRANSFERRED
}

enum AttendeeType {
  TICKET_HOLDER
  RSVP
  WAITLIST
  ORGANIZER
  VENDOR
  VIP_GUEST
}

enum LoyaltyTransactionType {
  EARNED
  REDEEMED
  EXPIRED
  ADJUSTED
  BONUS
  REFUNDED
}

enum LoyaltyRedemptionStatus {
  PENDING
  APPLIED
  CANCELLED
  EXPIRED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PREPARING
  READY
  COMPLETED
  CANCELLED
  REFUNDED
}

enum HeistStatus {
  SUCCESS
  FAILED_COOLDOWN
  FAILED_TARGET_PROTECTED
  FAILED_SHIELD
  FAILED_INSUFFICIENT_POINTS
  FAILED_INSUFFICIENT_TOKENS
  FAILED_INVALID_TARGET
}

enum HeistNotificationType {
  HEIST_SUCCESS
  HEIST_VICTIM
  TOKEN_EARNED
  SHIELD_ACTIVATED
  SHIELD_EXPIRED
}

// ===== HEIST ITEM SYSTEM =====

model HeistItem {
  id              Int      @id @default(autoincrement())
  name            String   @unique
  type            HeistItemType
  description     String
  coinCost        Int
  effectType      HeistItemEffectType
  effectValue     Float
  durationHours   Int?
  maxUses         Int?
  isActive        Boolean  @default(true)
  icon            String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  userInventories UserHeistItem[]
  usages          HeistItemUsage[]

  @@index([isActive])
  @@index([type])
}

model UserHeistItem {
  id              Int      @id @default(autoincrement())
  userId          Int
  itemId          Int
  quantity        Int      @default(1)
  purchasedAt     DateTime @default(now())
  expiresAt       DateTime?
  usesRemaining   Int?
  isActive        Boolean  @default(true)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  item            HeistItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId, isActive])
  @@index([expiresAt])
  @@index([userId, expiresAt])
}

model HeistItemUsage {
  id              Int      @id @default(autoincrement())
  heistId         Int
  userId          Int
  itemId          Int
  usedAt          DateTime @default(now())
  effectApplied   Json?
  heist           Heist    @relation(fields: [heistId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  item            HeistItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([heistId])
  @@index([userId])
  @@index([itemId])
}

enum HeistItemType {
  SWORD
  HAMMER
  SHIELD
}

enum HeistItemEffectType {
  INCREASE_STEAL_PERCENTAGE
  INCREASE_STEAL_BONUS
  REDUCE_THEFT_PERCENTAGE
  BLOCK_THEFT_CHANCE
  INCREASE_SUCCESS_RATE
}

enum NudgeType {
  INACTIVITY
  NEARBY_DEAL
  STREAK_REMINDER
  HAPPY_HOUR_ALERT
  WEATHER_BASED
}

enum NudgeFrequency {
  ONCE
  DAILY
  WEEKLY
  UNLIMITED
}

model Nudge {
  id                Int             @id @default(autoincrement())
  type              NudgeType
  title             String          @db.VarChar(100)
  message           String          @db.VarChar(500)
  triggerCondition  Json
  frequency         NudgeFrequency  @default(WEEKLY)
  cooldownHours     Int             @default(24)
  activeStartTime   DateTime?
  activeEndTime     DateTime?
  timeWindowStart   String?
  timeWindowEnd     String?
  active            Boolean         @default(true)
  priority          Int             @default(0)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  createdBy         Int?
  userNudges        UserNudge[]

  @@index([active, type])
  @@index([priority])
}

model UserNudge {
  id            Int       @id @default(autoincrement())
  userId        Int
  nudgeId       Int
  sentAt        DateTime  @default(now())
  deliveredVia  String    @db.VarChar(20)
  delivered     Boolean   @default(false)
  opened        Boolean   @default(false)
  openedAt      DateTime?
  clicked       Boolean   @default(false)
  clickedAt     DateTime?
  dismissed     Boolean   @default(false)
  contextData   Json?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  nudge         Nudge     @relation(fields: [nudgeId], references: [id], onDelete: Cascade)

  @@index([userId, sentAt])
  @@index([nudgeId, sentAt])
  @@index([userId, nudgeId, sentAt])
  @@index([opened, clicked])
}

model UserNudgePreferences {
  id                    Int       @id @default(autoincrement())
  userId                Int       @unique
  enabled               Boolean   @default(true)
  inactivityEnabled     Boolean   @default(true)
  nearbyDealEnabled     Boolean   @default(true)
  streakReminderEnabled Boolean   @default(true)
  happyHourAlertEnabled Boolean   @default(true)
  weatherBasedEnabled   Boolean   @default(true)
  quietHoursStart       String?
  quietHoursEnd         String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, enabled])
}

// ===== BOUNTY PROGRESS SYSTEM =====

model BountyProgress {
  id                Int      @id @default(autoincrement())
  userId            Int
  dealId            Int
  referralCount     Int      @default(0)
  rewardsEarned     Float    @default(0)
  isCompleted       Boolean  @default(false)
  completedAt       DateTime?
  qrCodeScannedAt   DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deal              Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)

  @@unique([userId, dealId])
  @@index([userId])
  @@index([dealId])
  @@index([isCompleted])
}

// ===== GUESS THE KITTY GAME SYSTEM =====

model KittyGame {
  id              Int            @id @default(autoincrement())
  merchantId      Int
  title           String         @db.VarChar(200)
  prizePool       Float          @default(0)
  entryFee        Int            @default(10) // Cost in coins to enter
  secretValue     Float?         // The random value players try to guess
  guessWindowStart DateTime
  guessWindowEnd   DateTime
  status          KittyGameStatus @default(PENDING)
  winnerId        Int?
  winnerGuessId   Int?
  minPlayers      Int            @default(2)
  maxPlayers      Int?
  createdBy       Int
  resolvedAt      DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  merchant        Merchant       @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  winner          User?          @relation("KittyGameWinner", fields: [winnerId], references: [id])
  creator         User           @relation("KittyGameCreator", fields: [createdBy], references: [id])
  guesses         KittyGuess[]

  @@index([merchantId, status])
  @@index([status])
  @@index([guessWindowEnd])
  @@index([winnerId])
}

model KittyGuess {
  id          Int       @id @default(autoincrement())
  gameId      Int
  userId      Int
  guessValue  Float
  coinsSpent  Int       @default(0)
  isWinner    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  game        KittyGame @relation(fields: [gameId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([gameId, userId])
  @@index([gameId])
  @@index([userId])
  @@index([isWinner])
}

enum KittyGameStatus {
  PENDING
  ACTIVE
  CLOSED
  RESOLVED
  CANCELLED
}
